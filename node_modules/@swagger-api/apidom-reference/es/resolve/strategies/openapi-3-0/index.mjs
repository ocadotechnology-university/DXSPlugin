import stampit from 'stampit';
<<<<<<< HEAD
import { createNamespace, visit } from '@swagger-api/apidom-core';
import openapi3_0Namespace, { getNodeType, isOpenApi3_0Element, keyMap, mediaTypes } from '@swagger-api/apidom-ns-openapi-3-0';
import ResolveStrategy from "../ResolveStrategy.mjs";
import ReferenceSet from "../../../ReferenceSet.mjs";
import Reference from "../../../Reference.mjs";
import { merge as mergeOptions } from "../../../options/util.mjs";
import OpenApi3_0ResolveVisitor from "./visitor.mjs"; // @ts-ignore
const visitAsync = visit[Symbol.for('nodejs.util.promisify.custom')];

// eslint-disable-next-line @typescript-eslint/naming-convention
=======
import ResolveStrategy from "../ResolveStrategy.mjs";
import ReferenceSet from "../../../ReferenceSet.mjs";
import { merge as mergeOptions } from "../../../options/util.mjs";
import UnmatchedDereferenceStrategyError from "../../../errors/UnmatchedDereferenceStrategyError.mjs"; // eslint-disable-next-line @typescript-eslint/naming-convention
>>>>>>> master
const OpenApi3_0ResolveStrategy = stampit(ResolveStrategy, {
  init() {
    this.name = 'openapi-3-0';
  },
  methods: {
<<<<<<< HEAD
    canResolve(file) {
      var _file$parseResult;
      // assert by media type
      if (file.mediaType !== 'text/plain') {
        return mediaTypes.includes(file.mediaType);
      }

      // assert by inspecting ApiDOM
      return isOpenApi3_0Element((_file$parseResult = file.parseResult) === null || _file$parseResult === void 0 ? void 0 : _file$parseResult.api);
    },
    async resolve(file, options) {
      const namespace = createNamespace(openapi3_0Namespace);
      const reference = Reference({
        uri: file.uri,
        value: file.parseResult
      });
      const mergedOptions = mergeOptions(options, {
        resolve: {
          internal: false
        }
      });
      const visitor = OpenApi3_0ResolveVisitor({
        reference,
        namespace,
        options: mergedOptions
      });
      const refSet = ReferenceSet();
      refSet.add(reference);
      await visitAsync(refSet.rootRef.value, visitor, {
        keyMap,
        nodeTypeGetter: getNodeType
      });
=======
    canResolve(file, options) {
      const dereferenceStrategy = options.dereference.strategies.find(strategy => strategy.name === 'openapi-3-0');
      if (dereferenceStrategy === undefined) {
        return false;
      }
      return dereferenceStrategy.canDereference(file, options);
    },
    async resolve(file, options) {
      const dereferenceStrategy = options.dereference.strategies.find(strategy => strategy.name === 'openapi-3-0');
      if (dereferenceStrategy === undefined) {
        throw new UnmatchedDereferenceStrategyError('"openapi-3-0" dereference strategy is not available.');
      }
      const refSet = ReferenceSet();
      const mergedOptions = mergeOptions(options, {
        resolve: {
          internal: false
        },
        dereference: {
          refSet
        }
      });
      await dereferenceStrategy.dereference(file, mergedOptions);
>>>>>>> master
      return refSet;
    }
  }
});
export default OpenApi3_0ResolveStrategy;