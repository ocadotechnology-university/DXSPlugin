'use strict';

var backendCommon = require('@backstage/backend-common');
var express = require('express');
var Router = require('express-promise-router');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var express__default = /*#__PURE__*/_interopDefaultLegacy(express);
var Router__default = /*#__PURE__*/_interopDefaultLegacy(Router);

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const migrationsDir = backendCommon.resolvePackagePath(
  "@backstage/plugin-bazaar-backend",
  "migrations"
);
class DatabaseHandler {
  constructor(client) {
    __publicField(this, "client");
    __publicField(this, "columns", [
      "metadata.id",
      "metadata.entity_ref",
      "metadata.title",
      "metadata.description",
      "metadata.status",
      "metadata.updated_at",
      "metadata.community",
      "metadata.size",
      "metadata.start_date",
      "metadata.end_date",
      "metadata.responsible",
      "metadata.docs"
    ]);
    this.client = client;
  }
  static async create(options) {
    var _a;
    const { database } = options;
    const client = await database.getClient();
    if (!((_a = database.migrations) == null ? void 0 : _a.skip)) {
      await client.migrate.latest({
        directory: migrationsDir
      });
    }
    return new DatabaseHandler(client);
  }
  async getMembers(id) {
    return await this.client.select("*").from("members").where({ item_id: id });
  }
  async addMember(id, userId, userRef, picture) {
    await this.client.insert({
      item_id: id,
      user_id: userId,
      user_ref: userRef,
      picture
    }).into("members");
  }
  async deleteMember(id, userId) {
    return await this.client("members").where({ item_id: id }).andWhere("user_id", userId).del();
  }
  async getMetadataById(id) {
    const coalesce = this.client.raw(
      "coalesce(count(members.item_id), 0) as members_count"
    );
    return await this.client("metadata").select([...this.columns, coalesce]).where({ "metadata.id": id }).groupBy(this.columns).leftJoin("members", "metadata.id", "=", "members.item_id");
  }
  async getMetadataByRef(entityRef) {
    const coalesce = this.client.raw(
      "coalesce(count(members.item_id), 0) as members_count"
    );
    return await this.client("metadata").select([...this.columns, coalesce]).where({ "metadata.entity_ref": entityRef }).groupBy(this.columns).leftJoin("members", "metadata.id", "=", "members.item_id");
  }
  async insertMetadata(bazaarProject) {
    const {
      title,
      entityRef,
      community,
      description,
      docs,
      status,
      size,
      startDate,
      endDate,
      responsible
    } = bazaarProject;
    await this.client.insert({
      title,
      entity_ref: entityRef,
      community,
      description,
      docs,
      status,
      updated_at: (/* @__PURE__ */ new Date()).toISOString(),
      size,
      start_date: startDate,
      end_date: endDate,
      responsible
    }).into("metadata");
  }
  async updateMetadata(bazaarProject) {
    const {
      title,
      id,
      entityRef,
      community,
      description,
      docs,
      status,
      size,
      startDate,
      endDate,
      responsible
    } = bazaarProject;
    return await this.client("metadata").where({ id }).update({
      title,
      entity_ref: entityRef,
      description,
      community,
      docs,
      status,
      updated_at: (/* @__PURE__ */ new Date()).toISOString(),
      size,
      start_date: startDate,
      end_date: endDate,
      responsible
    });
  }
  async deleteMetadata(id) {
    return await this.client("metadata").where({ id }).del();
  }
  async getProjects(limit, order) {
    const coalesce = this.client.raw(
      "coalesce(count(members.item_id), 0) as members_count"
    );
    let get = this.client("metadata").select([...this.columns, coalesce]).groupBy(this.columns);
    if (limit) {
      get = get.limit(limit);
    }
    if (order === "latest") {
      get = get.orderByRaw("id desc");
    }
    if (order === "random") {
      get = get.orderByRaw("RANDOM()");
    }
    return await get.leftJoin("members", "metadata.id", "=", "members.item_id");
  }
}

async function createRouter(options) {
  const { logger, database, identity } = options;
  const dbHandler = await DatabaseHandler.create({ database });
  logger.info("Initializing Bazaar backend");
  const router = Router__default["default"]();
  router.use(express__default["default"].json());
  router.get("/projects/:id/members", async (request, response) => {
    const members = await dbHandler.getMembers(request.params.id);
    if (members == null ? void 0 : members.length) {
      response.json({ status: "ok", data: members });
    } else {
      response.json({ status: "ok", data: [] });
    }
  });
  router.put("/projects/:id/member/:userId", async (request, response) => {
    var _a;
    const { id, userId } = request.params;
    const user = await identity.getIdentity({ request });
    await dbHandler.addMember(
      parseInt(id, 10),
      userId,
      user == null ? void 0 : user.identity.userEntityRef,
      (_a = request.body) == null ? void 0 : _a.picture
    );
    response.json({ status: "ok" });
  });
  router.delete("/projects/:id/member/:userId", async (request, response) => {
    const { id, userId } = request.params;
    const count = await dbHandler.deleteMember(parseInt(id, 10), userId);
    if (count) {
      response.json({ status: "ok" });
    } else {
      response.status(404).json({ message: "Record not found" });
    }
  });
  router.get("/projects/:idOrRef", async (request, response) => {
    const idOrRef = decodeURIComponent(request.params.idOrRef);
    let data;
    if (/^-?\d+$/.test(idOrRef)) {
      data = await dbHandler.getMetadataById(parseInt(idOrRef, 10));
    } else {
      data = await dbHandler.getMetadataByRef(idOrRef);
    }
    response.json({ status: "ok", data });
  });
  router.get("/projects", async (request, response) => {
    var _a, _b;
    const limit = (_a = request.query.limit) == null ? void 0 : _a.toString();
    const order = (_b = request.query.order) == null ? void 0 : _b.toString();
    const data = await dbHandler.getProjects(
      limit ? parseInt(limit, 10) : void 0,
      order
    );
    response.json({ status: "ok", data });
  });
  router.put("/projects", async (request, response) => {
    const bazaarProject = request.body;
    const count = await dbHandler.updateMetadata(bazaarProject);
    if (count) {
      response.json({ status: "ok" });
    }
  });
  router.post("/projects", async (request, response) => {
    const bazaarProject = request.body;
    await dbHandler.insertMetadata(bazaarProject);
    response.json({ status: "ok" });
  });
  router.delete("/projects/:id", async (request, response) => {
    const id = decodeURIComponent(request.params.id);
    const count = await dbHandler.deleteMetadata(parseInt(id, 10));
    if (count) {
      response.json({ status: "ok" });
    } else {
      response.status(404).json({ message: "Record not found" });
    }
  });
  router.use(backendCommon.errorHandler());
  return router;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router-fd8ba920.cjs.js.map
