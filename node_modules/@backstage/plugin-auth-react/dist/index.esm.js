import React, { useMemo, useCallback, useEffect } from 'react';
import { ErrorPanel } from '@backstage/core-components';
import { useApi, fetchApiRef, discoveryApiRef, useApp } from '@backstage/core-plugin-api';
import { Button } from '@material-ui/core';
import { useAsync, useMountEffect } from '@react-hookz/web';
import { ResponseError } from '@backstage/errors';

function useCookieAuthRefresh(options) {
  const { pluginId, path = "/cookie" } = options != null ? options : {};
  const fetchApi = useApi(fetchApiRef);
  const discoveryApi = useApi(discoveryApiRef);
  const channel = useMemo(() => {
    return "BroadcastChannel" in window ? new BroadcastChannel(`${pluginId}-auth-cookie-expires-at`) : null;
  }, [pluginId]);
  const [state, actions] = useAsync(async () => {
    const apiOrigin = await discoveryApi.getBaseUrl(pluginId);
    const requestUrl = `${apiOrigin}${path}`;
    const response = await fetchApi.fetch(`${requestUrl}`, {
      credentials: "include"
    });
    if (!response.ok) {
      throw await ResponseError.fromResponse(response);
    }
    const data = await response.json();
    if (!data.expiresAt) {
      throw new Error("No expiration date found in response");
    }
    return data;
  });
  useMountEffect(actions.execute);
  const retry = useCallback(() => {
    actions.execute();
  }, [actions]);
  const refresh = useCallback(
    (params) => {
      const margin = (1 + 3 * Math.random()) * 6e4;
      const delay = Date.parse(params.expiresAt) - Date.now() - margin;
      const timeout = setTimeout(retry, delay);
      return () => clearTimeout(timeout);
    },
    [retry]
  );
  useEffect(() => {
    if (state.status !== "success" || !state.result) {
      return () => {
      };
    }
    channel == null ? void 0 : channel.postMessage({
      action: "COOKIE_REFRESH_SUCCESS",
      payload: state.result
    });
    let cancel = refresh(state.result);
    const listener = (event) => {
      const { action, payload } = event.data;
      if (action === "COOKIE_REFRESH_SUCCESS") {
        cancel();
        cancel = refresh(payload);
      }
    };
    channel == null ? void 0 : channel.addEventListener("message", listener);
    return () => {
      cancel();
      channel == null ? void 0 : channel.removeEventListener("message", listener);
    };
  }, [state, refresh, channel]);
  if (state.status === "not-executed") {
    return { status: "loading" };
  }
  if (state.status === "loading" && !state.result) {
    return { status: "loading" };
  }
  if (state.status === "loading" && state.error) {
    return { status: "loading" };
  }
  if (state.status === "error" && state.error) {
    return { status: "error", error: state.error, retry };
  }
  return { status: "success", data: state.result };
}

function CookieAuthRefreshProvider(props) {
  const { children, ...options } = props;
  const app = useApp();
  const { Progress } = app.getComponents();
  const result = useCookieAuthRefresh(options);
  if (result.status === "loading") {
    return /* @__PURE__ */ React.createElement(Progress, null);
  }
  if (result.status === "error") {
    return /* @__PURE__ */ React.createElement(ErrorPanel, { error: result.error }, /* @__PURE__ */ React.createElement(Button, { variant: "outlined", onClick: result.retry }, "Retry"));
  }
  return /* @__PURE__ */ React.createElement(React.Fragment, null, children);
}

export { CookieAuthRefreshProvider, useCookieAuthRefresh };
//# sourceMappingURL=index.esm.js.map
