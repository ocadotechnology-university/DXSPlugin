import { Progress, ResponseErrorPanel, Link, OverflowTooltip, InfoCard } from '@backstage/core-components';
import { catalogApiRef, humanizeEntityRef, getEntityRelations, useEntity } from '@backstage/plugin-catalog-react';
import { makeStyles, createStyles, Grid, Box, Typography, List, ListItem, ListItemText, ListItemSecondaryAction, Tooltip, Switch } from '@material-ui/core';
import React, { useState, useEffect } from 'react';
import { useApi, useRouteRef } from '@backstage/core-plugin-api';
import pluralize from 'pluralize';
import { c as catalogIndexRouteRef } from './routes-e3daad75.esm.js';
import { parseEntityRef, stringifyEntityRef, RELATION_MEMBER_OF, RELATION_PARENT_OF } from '@backstage/catalog-model';
import limiterFactory from 'p-limit';
import useAsync from 'react-use/lib/useAsync';
import qs from 'qs';
import { uniq } from 'lodash';

const limiter = limiterFactory(10);
const getQueryParams = (ownersEntityRef, selectedEntity) => {
  const { kind, type } = selectedEntity;
  const owners = ownersEntityRef.map(
    (owner) => humanizeEntityRef(parseEntityRef(owner), { defaultKind: "group" })
  );
  const filters = {
    kind: kind.toLocaleLowerCase("en-US"),
    type,
    owners,
    user: "all"
  };
  return qs.stringify({ filters }, { arrayFormat: "repeat" });
};
const getMemberOfEntityRefs = (owner) => {
  const parentGroups = getEntityRelations(owner, RELATION_MEMBER_OF, {
    kind: "Group"
  });
  const ownerGroupsNames = parentGroups.map(
    ({ kind, namespace, name }) => stringifyEntityRef({
      kind,
      namespace,
      name
    })
  );
  return [...ownerGroupsNames, stringifyEntityRef(owner)];
};
const isEntity = (entity) => entity !== void 0;
const getChildOwnershipEntityRefs = async (entity, catalogApi, alreadyRetrievedParentRefs = []) => {
  const childGroups = getEntityRelations(entity, RELATION_PARENT_OF, {
    kind: "Group"
  });
  const hasChildGroups = childGroups.length > 0;
  const entityRef = stringifyEntityRef(entity);
  if (hasChildGroups) {
    const entityRefs = childGroups.map((r) => stringifyEntityRef(r));
    const childGroupResponse = await catalogApi.getEntitiesByRefs({
      fields: ["kind", "metadata.namespace", "metadata.name", "relations"],
      entityRefs
    });
    const childGroupEntities = childGroupResponse.items.filter(isEntity);
    const unknownChildren = childGroupEntities.filter(
      (childGroupEntity) => !alreadyRetrievedParentRefs.includes(
        stringifyEntityRef(childGroupEntity)
      )
    );
    const childrenRefs = (await Promise.all(
      unknownChildren.map(
        (childGroupEntity) => limiter(
          () => getChildOwnershipEntityRefs(childGroupEntity, catalogApi, [
            ...alreadyRetrievedParentRefs,
            entityRef
          ])
        )
      )
    )).flatMap((aggregated) => aggregated);
    return uniq([...childrenRefs, entityRef]);
  }
  return [entityRef];
};
const getOwners = async (entity, relations, catalogApi) => {
  const isGroup = entity.kind === "Group";
  const isAggregated = relations === "aggregated";
  const isUserEntity = entity.kind === "User";
  if (isAggregated && isGroup) {
    return getChildOwnershipEntityRefs(entity, catalogApi);
  }
  if (isAggregated && isUserEntity) {
    return getMemberOfEntityRefs(entity);
  }
  return [stringifyEntityRef(entity)];
};
const getOwnedEntitiesByOwners = (owners, kinds, catalogApi) => catalogApi.getEntities({
  filter: [
    {
      kind: kinds,
      "relations.ownedBy": owners
    }
  ],
  fields: [
    "kind",
    "metadata.name",
    "metadata.namespace",
    "spec.type",
    "relations"
  ]
});
function useGetEntities(entity, relations, entityFilterKind, entityLimit = 6) {
  const catalogApi = useApi(catalogApiRef);
  const kinds = entityFilterKind != null ? entityFilterKind : ["Component", "API", "System"];
  const {
    loading,
    error,
    value: componentsWithCounters
  } = useAsync(async () => {
    const owners = await getOwners(entity, relations, catalogApi);
    const ownedEntitiesList = await getOwnedEntitiesByOwners(
      owners,
      kinds,
      catalogApi
    );
    const counts = ownedEntitiesList.items.reduce(
      (acc, ownedEntity) => {
        var _a, _b;
        const match = acc.find(
          (x) => {
            var _a2;
            return x.kind === ownedEntity.kind && x.type === ((_a2 = ownedEntity.spec) == null ? void 0 : _a2.type);
          }
        );
        if (match) {
          match.count += 1;
        } else {
          acc.push({
            kind: ownedEntity.kind,
            type: (_b = (_a = ownedEntity.spec) == null ? void 0 : _a.type) == null ? void 0 : _b.toString(),
            count: 1
          });
        }
        return acc;
      },
      []
    );
    const topN = counts.sort((a, b) => b.count - a.count).slice(0, entityLimit);
    return topN.map((topOwnedEntity) => ({
      counter: topOwnedEntity.count,
      type: topOwnedEntity.type,
      kind: topOwnedEntity.kind,
      queryParams: getQueryParams(owners, topOwnedEntity)
    }));
  }, [catalogApi, entity, relations]);
  return {
    componentsWithCounters,
    loading,
    error
  };
}

const useStyles$1 = makeStyles(
  (theme) => createStyles({
    card: {
      border: `1px solid ${theme.palette.divider}`,
      boxShadow: theme.shadows[2],
      borderRadius: "4px",
      padding: theme.spacing(2),
      transition: `${theme.transitions.duration.standard}ms`,
      "&:hover": {
        boxShadow: theme.shadows[4]
      },
      height: "100%"
    },
    bold: {
      fontWeight: theme.typography.fontWeightBold
    },
    smallFont: {
      fontSize: theme.typography.body2.fontSize
    },
    entityTypeBox: {
      background: (props) => theme.getPageTheme({ themeId: props.type }).backgroundImage,
      color: (props) => theme.getPageTheme({ themeId: props.type }).fontColor
    }
  })
);
const EntityCountTile = ({
  counter,
  type,
  kind,
  url
}) => {
  const classes = useStyles$1({ type: type != null ? type : kind });
  const rawTitle = type != null ? type : kind;
  const isLongText = rawTitle.length > 10;
  return /* @__PURE__ */ React.createElement(Link, { to: url, variant: "body2" }, /* @__PURE__ */ React.createElement(
    Box,
    {
      className: `${classes.card} ${classes.entityTypeBox}`,
      display: "flex",
      flexDirection: "column",
      alignItems: "center"
    },
    /* @__PURE__ */ React.createElement(Typography, { className: classes.bold, variant: "h6" }, counter),
    /* @__PURE__ */ React.createElement(Box, { sx: { width: "100%", textAlign: "center" } }, /* @__PURE__ */ React.createElement(
      Typography,
      {
        className: `${classes.bold} ${isLongText && classes.smallFont}`,
        variant: "h6"
      },
      /* @__PURE__ */ React.createElement(
        OverflowTooltip,
        {
          text: pluralize(rawTitle.toLocaleUpperCase("en-US"), counter)
        }
      )
    )),
    type && /* @__PURE__ */ React.createElement(Typography, { variant: "subtitle1" }, kind)
  ));
};
const ComponentsGrid = ({
  entity,
  relationsType,
  entityFilterKind,
  entityLimit = 6
}) => {
  const catalogLink = useRouteRef(catalogIndexRouteRef);
  const { componentsWithCounters, loading, error } = useGetEntities(
    entity,
    relationsType,
    entityFilterKind,
    entityLimit
  );
  if (loading) {
    return /* @__PURE__ */ React.createElement(Progress, null);
  } else if (error) {
    return /* @__PURE__ */ React.createElement(ResponseErrorPanel, { error });
  }
  return /* @__PURE__ */ React.createElement(Grid, { container: true }, componentsWithCounters == null ? void 0 : componentsWithCounters.map((c) => {
    var _a;
    return /* @__PURE__ */ React.createElement(Grid, { item: true, xs: 6, md: 6, lg: 4, key: (_a = c.type) != null ? _a : c.kind }, /* @__PURE__ */ React.createElement(
      EntityCountTile,
      {
        counter: c.counter,
        kind: c.kind,
        type: c.type,
        url: `${catalogLink()}/?${c.queryParams}`
      }
    ));
  }));
};

const useStyles = makeStyles((theme) => ({
  list: {
    [theme.breakpoints.down("xs")]: {
      padding: `0 0 12px`
    }
  },
  listItemText: {
    [theme.breakpoints.down("xs")]: {
      paddingRight: 0,
      paddingLeft: 0
    }
  },
  listItemSecondaryAction: {
    [theme.breakpoints.down("xs")]: {
      width: "100%",
      top: "auto",
      right: "auto",
      position: "relative",
      transform: "unset"
    }
  }
}));
const OwnershipCard = (props) => {
  const {
    variant,
    entityFilterKind,
    hideRelationsToggle,
    relationsType,
    entityLimit = 6
  } = props;
  const relationsToggle = hideRelationsToggle === void 0 ? false : hideRelationsToggle;
  const classes = useStyles();
  const { entity } = useEntity();
  const defaultRelationsType = entity.kind === "User" ? "aggregated" : "direct";
  const [getRelationsType, setRelationsType] = useState(
    relationsType != null ? relationsType : defaultRelationsType
  );
  useEffect(() => {
    if (!relationsType) {
      setRelationsType(defaultRelationsType);
    }
  }, [setRelationsType, defaultRelationsType, relationsType]);
  return /* @__PURE__ */ React.createElement(InfoCard, { title: "Ownership", variant }, !relationsToggle && /* @__PURE__ */ React.createElement(List, { dense: true }, /* @__PURE__ */ React.createElement(ListItem, { className: classes.list }, /* @__PURE__ */ React.createElement(ListItemText, { className: classes.listItemText }), /* @__PURE__ */ React.createElement(
    ListItemSecondaryAction,
    {
      className: classes.listItemSecondaryAction
    },
    "Direct Relations",
    /* @__PURE__ */ React.createElement(
      Tooltip,
      {
        placement: "top",
        arrow: true,
        title: `${getRelationsType === "direct" ? "Direct" : "Aggregated"} Relations`
      },
      /* @__PURE__ */ React.createElement(
        Switch,
        {
          color: "primary",
          checked: getRelationsType !== "direct",
          onChange: () => {
            const updatedRelationsType = getRelationsType === "direct" ? "aggregated" : "direct";
            setRelationsType(updatedRelationsType);
          },
          name: "pin",
          inputProps: { "aria-label": "Ownership Type Switch" }
        }
      )
    ),
    "Aggregated Relations"
  ))), /* @__PURE__ */ React.createElement(
    ComponentsGrid,
    {
      entity,
      entityLimit,
      relationsType: getRelationsType,
      entityFilterKind
    }
  ));
};

export { OwnershipCard };
//# sourceMappingURL=OwnershipCard-9f8835e6.esm.js.map
